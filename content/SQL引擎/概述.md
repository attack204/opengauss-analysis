---
# Title, summary, and page position.
title: SQL引擎概述 
linktitle: SQL引擎概述
summary: SQL引擎概述
weight: 1
# icon: book
# icon_pack: fas

# Page metadata.
date: '2022-06-15T00:00:00Z'
type: book # Do not modify.
toc: true
---


# 1 SQL解析

词法分析：从查询语句中识别出系统支持的关键字、标识符、运算符等

语法分析：根据词法分析的结果，为每个“词”匹配相应的语法规则，并生成相应的抽象树(AST)

语义分析：对语法树进行有效性检查，检查语法树中对应的表、列、函数、表达式是否有对应的元数据，将AST转化为查询计划

![](https://cdn.attack204.com/iShot2022-06-15_12.42.10.png)


# 2 查询优化

查询优化的技术有

1. RBO(Rule Based Optimizaiton, 基于规则的查询优化)：根据预定义的启发式规则对SQL语句进行优化
2. CBO(Cost Based Optimization, 基于代价的查询优化)：对SQL语句对应的待选执行路径进行代价估算，从待选路径中选择代价最低的执行路径作为最终的执行计划
3. ABO(AI Based Optimization)：根据AI经验对查询进行优化

openGauss采用CBO的方式，同时也在探索ABO模式

## 2.1 查询重写

### 2.1.1 概念

顾名思义就是对查询的语句改变顺序以提高其查询效率

需要遵循的基本原则：等价性与高效性

### 2.1.2 关系代数式等价变化

根据关系代数式的等价变化，灵活地利用关系代数的等价关系来进行优化推导

1. 借助分配律使操作下推
2. 生成候选的执行计划，再由优化器根据估算的代价进行筛选

### 2.1.3 常见的查询重写技术

### 1. 常量表达式化简

例如`SELECT * FROM TABLE where c1=1+1`可以重写成`SELECT * FROM TABLE where c1=2`

### 2. 子查询优化

按照子查询是否与父查询有关，可以分为`相关子查询`和`非相关子查询`

a. 对于相关子查询:可以找到其等价的Join，并选择最优的。例如Semi Join技术

b. 对于非相关子查询：可以先算出子查询的内容并缓存下来。

### 3. 选择下推和等价推理

这里有张图比较好描述

假设查询语句为`SELECT t1.c1, t2.c1 FROM TB WHERE t1.c1 = t2.c1 AND t1.c1 = 1`

图1:暴力查询，先读出两表的数据做JOIN，然后从tmp表中选择`t1.c1 = t2.c1`的行，再从结果中选择`t1.c1=1`的行

图2:选择下推。先在t1表中选择`t1.c1=1`的行，再做JOIN

图3:等价推理。根据`t1.c1 = t2.c1 AND t1.c1 = 1`可以推出`t2.c1 = 1`，那么可以现在t1表中选择`t1.c1 = 1`的行，并在t2表中选择`t2.c1 = 1`的行，再JOIN

图4：发现查出来的结果一定满足条件，因此不需要JOIN


![](https://cdn.attack204.com/20220615194344.png)

### 4. 外链接消除

外链接和内链接的本质区别是外链接可能有NULL值，如果查询语句中有条件过滤掉了NULL值，那么可以直接将外链接转化为内链接

### 5. DISTINCT消除

DISTINCT如果有主键约束，那么DISTINCT无效，可以直接删除

### 6. IN谓词展开

例如将`c1 IN (10, 20, 30)`转化为`c1 = 10 or c1 = 20 or c1 = 30`有助于使用索引减少过滤条件

### 7. 视图展开

![](https://cdn.attack204.com/20220615214420.png)


## 2.2 路径搜素

语义分析过后需要针对某个SQL获取最优解，即针对语法树的连接顺序求出最优执行路径

按照算法不同可以分为三种

1. 自底向上模式

过程：扫描表 => 生成扫描算子 => 生成连接算子 => 生成物理执行计划 

![](https://cdn.attack204.com/20220616140357.png)

2. 自顶向下模式 

需要采用OO，由于Gauss采用的OP，因此不适用

![](https://cdn.attack204.com/20220616140423.png)


3. 随机搜索模式


openGauss采用的是自底向上模式和随机搜索的结合

### 2.2.1 单表扫描路径搜索

自底向上的路径搜索方法最低层需要进行单表扫描

对于单表扫描，一般有两种形式

1. 全表扫描：优点：顺序IO，缺点：需要扫描全表
2. 索引扫描：优点：可以借助索引减少扫描量，缺点：当索引选择性差时会产生大量随机IO

具体需要哪种方式依然需要trade off

举例：

![](https://cdn.attack204.com/20220616141433.png)

![](https://cdn.attack204.com/20220616141444.png)


### 2.2.2 多表连接路径搜索

难点：1. 枚举表的连接顺序 2. 枚举表的连接算法

openGauss采用自底向上的路径搜索算法，首先生成每个表的扫描路径，然后逐层合并，具体过程如下

![](https://cdn.attack204.com/20220616141717.png)

实际上多表路径扫描问题为NP问题，Gauss采用的算法如下

1. 当关联表的个数较少时，采用动态规划算法
2. 当关联表的个数增多时，采用遗传算法

同时采取以下三种剪枝策略

1. 尽可能先考虑有连接条件的路径，尽量推迟笛卡尔积运算
2. 在搜索过程中基于代价估算对执行路径进行筛选，并基于分支限界技术和启发式规则进行剪枝，放弃一些代价较高的执行路径
3. 保留具有特殊物理属性的执行路径，例如有些执行路径的结果具有排序性，这些路径可能在后续的优化过程中避免再次被排序

### 2.2.3 分布式路径搜索

这一块没咋看懂

大概意思就是考虑分布式条件下同一个表的数据可能分布在不同的DN上，因此SELECT的时候需要对数据进行重新分布。

openGauss增加了两个算子来解决上述问题

1. Redistribute：将一个表的数据按照执行的哈希值在所有DN上做重分布
2. BroadCast

### 2.2.4 利用物理属性优化

即想办法使得被查询的数据尽量有序或者尽可能多的采用中间结果

常用方法：

1. B+树
2. 哈希表
3. 排序：注意在数据量大时需要进行外排序
4. 物化：指将扫描或连接产生的中间结果保存起来，如果中间结果比较大可能需要将结果写入外存（这个过程中可能会产生一部分IO代价）。在具体执行时会对物化和非物化都计算一次代价，并最终取小的一个。

## 2.3 代价估算

即对路径搜索过程中生成的多个执行计划进行代价估算

在进行代价估算时往往需要以下几个信息

### 2.3.1 统计信息

统计信息包括表的元组数量（N），表占有的页面数（B），而列级的统计信息则主要包括属性的宽度（W），属性的最大值（Max），最小值（Min），高频值等（MCV）等

openGauss会针对得到的统计数据绘制等高直方图

可以使用Analyze命令进行手动统计，但需要注意，统计信息收集的频率太低，会导致统计信息的滞后，统计的频率过高，则会间接影响查询性能

### 2.3.2 选择率

对于单表，选择率的定义为

$$
选择率 = \frac{约束条件过滤前的元组数量}{约束条件过滤后的元组数量}
$$

对于多表，选择率可以通过合取范式或析取范式来定义

合取范式：$$P(A and B) = P(A) + P(B) - P(AB)$$

析取范式：$P(AB) = P(A)P(B)$

例如

![](https://cdn.attack204.com/20220616144825.png)


### 2.3.3 代价估算方法

openGauss的优化器是基于代价的优化器，对于每个查询生成多个候选计划，并对于每个计划计算出执行代价，从中选择代价最小的执行计划。

确定代价的流程为

根据约束条件确定选择率 => 确定计划路径需要的行数 => 根据行数推算出对应的页面数 => 根据页面信息计算IO代价，根据元组信息计算CPU代价，根据数据分布计算通信代价

即总的代价表示为

$$总代价 = IO代价 + CPU代价 + 通信代价$$

具体数值的计算采用如下方法

把顺序扫描页面的代价记为1，其他算子的代价都归化到1上，比如把随机扫描页面的代价定义为4，把CPU处理一条元组的代价定义为0.01。

这里的总代价仅仅包含了数据查询和JOIN的代价，在实际的过程中还需要考虑算子输出第一条元组的代价。

具体的过程还是挺复杂的，先引用一下原书的内容，后面再补

![](https://cdn.attack204.com/20220616145758.png)

![](https://cdn.attack204.com/20220616145826.png)